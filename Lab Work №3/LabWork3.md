# Лабораторная работа №3

## 1. Диаграмма компонентов
Диаграмма компонентов для микросервиса авторизации внутри системы. 
![image](lab31.png)

## 2. Диаграмма последовательностей

Диаграмма последовательностей для микросервиса авторизации.
![image](lab33.png)

Пояснения диаграммы последовательностей:

1. Пользователь подает запросы в API, cистема связывается с серверной частью и проверяет наличие попытки входа (начала сессии);
2. Если вход будет выполнен успешно:
    * Пользователь вводит логин и пароль;
    * API передает полученные от пользователя данные в модуль авторизации;
    * Сервис ищет совпадения полученных данных с имеющимися в базе данных;
    * База данных возвращает ответ о наличии совпадений в модуль авторизации;
    * Модуль авторизации передает токен доступа в API;
    * Пользователь попадает на страницу личного кабинета.
3. Если вход выполнен НЕуспешно:
    * API передает запрос на полный повтор сесии;
    * Пользователь вновь видит то же окно авторизации.

## 3. Модель БД

## 4. Применение основных принципов разработки

    
#### Микросервис авторизации
```python
from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)

# подключение к PostgreSQL
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://login:password@localhost/dbsystem'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)

# модель для таблицы пользователей в бд
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password = db.Column(db.String(120), nullable=False)
    token = db.Column(db.String(120), nullable=False)

# API для взаимодействия с микросервисом авторизации (если пользователь найден и пароль совпадает, мы возвращаем токен доступа)
@app.route('/login', methods=['POST']) #эндпоинт /login
def login():
    username = request.json.get('login')
    password = request.json.get('password')

    user = User.query.filter_by(username=username).first()
    if user and user.password == password:
        return jsonify({"token": user.token}), 200
    else:
        return jsonify({"ошибка": "Вход не выполнен"}), 401

if __name__ == '__main__':
    app.run(debug=True)    
 ```

 Код отвечает нижеприведенным принципам разработки, так как:
 1. KISS (Keep It Simple, Stupid) - Архитектура модуля понятна и проста: веб-сервис на Flask, который работает с базой данных PostgreSQL для аутентификации.
 2. YAGNI (You Aren't Gonna Need It) - Реализована только функциональность аутентификации пользователей, без лишних функций (напоминаю, что структура всего веб-сервиса микросервисная).
 3. DRY (Don't Repeat Yourself) - в микросервисе нет повторяющихся кусков кода. Также в функции login, мы используем общий метод доступа к базе данных через User.query.filter_by(username=username).first(). Этот код повторяется при проверке аутентификации пользователя в разных частях приложения. Если в будущем потребуется изменить логику получения пользователя из базы данных, это можно будет сделать только в одном месте в коде. 
 4. SOLID (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) - User модель следует принципу единственной ответственности, отвечая только за описание таблицы пользователей, а также вся архитектура микросервиса открыта и расширяема, позволяя как масштабировать приложение, так и менять уже существующие структуры без существенных изменений всего кода в целом.
    
### 5. Дополнительные принципы

1. BDUF. Big Design Up Front («Масштабное проектирование прежде всего»).
Отказ: Для данного фрагмента кода нет необходимости проводить масштабное проектирование заранее. Код отражает лишь маленькую часть функциональности веб-сервиса, только метод аутентификации. 

2. SoC. Separation of Concerns (Принцип разделения ответственности):
Применимость: Приложение разделено на логические компоненты: модель пользователя, обработчик запроса аутентификации и API-эндпоинт. Каждый компонент отвечает за свою конкретную область ответственности.

3. MVP. Minimum Viable Product (Минимально жизнеспособный продукт):
Применимость: Данный фрагмент кода представляет собой часть функциональности, необходимой для работы приложения - механизм аутентификации. Он является частью MVP, так как без него пользователь не сможет войти в систему. 

4. PoC. Proof of Concept (Доказательство концепции):
Отказ: Для фрагмента кода, который реализует механизм аутентификации, нет необходимости проводить доказательство концепции. Этот фрагмент кода выполняет конкретную и явную задачу - проверку подлинности пользователя, и его работоспособность в данном контексте доказывается через тестирование.


